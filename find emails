/** Main function called by button **/
function FE_fillMissingEmailsAll() {
  const SHEET_NAME = 'People'; // names in A, emails in C
  const NAME_COL = 1;          // A
  const EMAIL_COL = 3;         // C

  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_NAME);
  if (!sh) throw new Error('Sheet "' + SHEET_NAME + '" not found');

  const lastRow = sh.getLastRow();
  if (lastRow < 2) {
    SpreadsheetApp.getUi().alert('No data rows');
    return;
  }

  const width = Math.max(NAME_COL, EMAIL_COL);
  const values = sh.getRange(2, 1, lastRow - 1, width).getDisplayValues();

  let filled = 0;
  for (let i = 0; i < values.length; i++) {
    const rowNumber = i + 2;
    const fullName = String(values[i][NAME_COL - 1] || '').trim();
    const currentEmail = String(values[i][EMAIL_COL - 1] || '').trim();

    if (!fullName || currentEmail) continue;

    const email = FE_findBestEmailByName(fullName);
    if (email) {
      sh.getRange(rowNumber, EMAIL_COL).setValue(email);
      filled++;
    }
  }

  SpreadsheetApp.getUi().alert('Emails filled: ' + filled);
}

/** Lookup flow: Contacts → Other Contacts → Legacy → Gmail history **/
function FE_findBestEmailByName(name) {
  const fromContacts = FE_searchPeopleContacts_(name);
  if (fromContacts) return fromContacts;

  const fromOther = FE_searchOtherContacts_(name);
  if (fromOther) return fromOther;

  const fromLegacy = FE_searchLegacyContacts_(name);
  if (fromLegacy) return fromLegacy;

  const fromGmail = FE_searchGmailHistory_(name);
  if (fromGmail) return fromGmail;

  return '';
}

/* ---------- People API: saved Contacts ---------- */
function FE_searchPeopleContacts_(name) {
  try {
    const resp = People.People.searchContacts({
      query: name,
      pageSize: 10,
      readMask: 'names,emailAddresses'
    });
    return FE_pickBestCandidate_(name, resp && resp.results);
  } catch (e) {}
  return '';
}

/* ---------- People API: Other contacts ---------- */
function FE_searchOtherContacts_(name) {
  try {
    const resp = People.OtherContacts.search({
      query: name,
      pageSize: 10,
      readMask: 'names,emailAddresses'
    });
    return FE_pickBestCandidate_(name, resp && resp.results);
  } catch (e) {}
  return '';
}

/* ---------- Legacy ContactsApp fallback ---------- */
function FE_searchLegacyContacts_(name) {
  try {
    const matches = ContactsApp.getContactsByName(name) || [];
    for (const c of matches) {
      const emails = c.getEmails();
      if (emails && emails.length) {
        const primary = emails.find(e => e.isPrimary());
        const addr = (primary || emails[0]).getAddress();
        if (addr) return addr.trim();
      }
    }
  } catch (e) {}
  return '';
}

/* ---------- Gmail history heuristic ---------- */
function FE_searchGmailHistory_(name) {
  try {
    const query = `from:(${name}) OR to:(${name}) OR cc:(${name})`;
    const threads = GmailApp.search(query, 0, 30);
    const counts = {};
    const normName = FE_normName_(name);

    for (const th of threads) {
      for (const m of th.getMessages()) {
        FE_collectHeaderEmails_(m.getFrom(), normName, counts);
        m.getTo().split(',').forEach(s => FE_collectHeaderEmails_(s, normName, counts));
        m.getCc().split(',').forEach(s => FE_collectHeaderEmails_(s, normName, counts));
        m.getBcc().split(',').forEach(s => FE_collectHeaderEmails_(s, normName, counts));
      }
    }

    const best = Object.entries(counts).sort((a, b) => b[1] - a[1])[0];
    return best ? best[0] : '';
  } catch (e) {}
  return '';
}

/* ---------- Helpers ---------- */
function FE_pickBestCandidate_(queryName, results) {
  if (!results || !results.length) return '';
  const candidates = [];
  const q = FE_normName_(queryName);

  results.forEach(r => {
    const p = r.person;
    if (!p || !p.emailAddresses) return;
    const display = FE_bestDisplayName_(p.names || []);
    const score = FE_nameScore_(q, FE_normName_(display));
    p.emailAddresses.forEach(e => {
      const value = (e.value || '').trim();
      if (!value) return;
      const primary = e.metadata && e.metadata.primary ? 1 : 0;
      candidates.push({ value, score, primary });
    });
  });

  candidates.sort((a, b) => {
    if (b.score !== a.score) return b.score - a.score;
    if (b.primary !== a.primary) return b.primary - a.primary;
    return a.value.localeCompare(b.value);
  });
  return candidates[0] ? candidates[0].value : '';
}

function FE_bestDisplayName_(names) {
  let best = '';
  for (const n of names) {
    if (n.metadata && n.metadata.primary && n.displayName) return n.displayName;
    if (!best && n.displayName) best = n.displayName;
  }
  return best;
}

function FE_normName_(s) {
  return String(s || '').toLowerCase()
    .replace(/["']/g, '')
    .replace(/\(.*?\)/g, ' ')
    .replace(/\b(mr|mrs|ms|miss|mx|dr|prof)\.?\b/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}

function FE_nameScore_(q, d) {
  let s = 0;
  if (d.includes(q)) s += 2;
  const qFirst = q.split(' ')[0] || '';
  if (qFirst && new RegExp('\\b' + qFirst.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b').test(d)) s += 1;
  return s;
}

function FE_collectHeaderEmails_(headerStr, normTargetName, counts) {
  const parts = String(headerStr || '').split(',');
  for (let raw of parts) {
    raw = raw.trim();
    if (!raw) continue;
    const m = raw.match(/^(.*)<([^>]+)>$/);
    let disp = '';
    let addr = '';
    if (m) {
      disp = m[1].trim();
      addr = m[2].trim();
    } else {
      addr = raw;
    }
    if (disp) {
      const nd = FE_normName_(disp);
      if (!nd || !FE_nameLikelyMatch_(normTargetName, nd)) continue;
    }
    if (addr && addr.includes('@')) {
      counts[addr] = (counts[addr] || 0) + 1;
    }
  }
}

function FE_nameLikelyMatch_(q, d) {
  if (d.includes(q)) return true;
  const qParts = q.split(' ').filter(Boolean);
  const dParts = d.split(' ').filter(Boolean);
  if (qParts.length >= 2) {
    const first = qParts[0];
    const last = qParts[qParts.length - 1];
    return dParts.includes(first) && dParts.includes(last);
  }
  return dParts.includes(qParts[0] || '');
}
